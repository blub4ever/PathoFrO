package com.patho.main.action.handler.views;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Configurable;

import com.patho.main.action.handler.GlobalEditViewHandler;
import com.patho.main.action.handler.GlobalEditViewHandler.StainingListAction;
import com.patho.main.model.patient.Slide;
import com.patho.main.model.patient.Task;
import com.patho.main.repository.TaskRepository;
import com.patho.main.service.SlideService;
import com.patho.main.ui.StainingTableChooser;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

/**
 * Savin receipt log data
 * 
 * @author andi
 *
 */
@Getter
@Setter
@Configurable
public class ReceiptLogView extends AbstractTaskView {

	@Autowired
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private SlideService slideService;

	@Autowired
	@Getter(AccessLevel.NONE)
	@Setter(AccessLevel.NONE)
	private TaskRepository taskRepository;

	/**
	 * Currently selected task in table form, transient, used for gui
	 */
	private ArrayList<StainingTableChooser<?>> stainingTableRows;

	/**
	 * Is used for selecting a chooser from the generated list (generated by task).
	 * It is used to edit the names of the entities by an overlaypannel
	 */
	private StainingTableChooser<?> selectedStainingTableChooser;

	/**
	 * This variable is used to save the selected action, which should be executed
	 * upon all selected slides
	 */
	private StainingListAction actionOnMany;

	public ReceiptLogView(GlobalEditViewHandler globalEditViewHandler) {
		super(globalEditViewHandler);
	}

	/**
	 * Toggles the status of a StainingTableChooser object and all chides.
	 * 
	 * @param chooser
	 */
	public void toggleChildrenChoosenFlag(StainingTableChooser<?> chooser) {
		setChildrenAsChoosen(chooser, !chooser.isChoosen());
	}

	/**
	 * Sets all children of a StainingTableChoosers to chosen/unchosen
	 * 
	 * @param chooser
	 * @param choosen
	 */
	public void setChildrenAsChoosen(StainingTableChooser<?> chooser, boolean chosen) {
		chooser.setChoosen(chosen);
		if (chooser.isSampleType() || chooser.isBlockType()) {
			for (StainingTableChooser<?> tmp : chooser.getChildren()) {
				setChildrenAsChoosen(tmp, chosen);
			}
		}

		setActionOnMany(StainingListAction.NONE);
	}

	/**
	 * Sets a lists of StainingTableChoosers to chosen/unchosen Setzt den Status
	 * einer Liste von StainingTableChoosers und ihrer Kinder
	 * 
	 * @param choosers
	 * @param choosen
	 */
	public void setListAsChoosen(List<StainingTableChooser<?>> choosers, boolean chosen) {
		for (StainingTableChooser<?> chooser : choosers) {
			if (chooser.isSampleType()) {
				setChildrenAsChoosen(chooser, chosen);
			}
		}
	}

	/**
	 * Executes an action on all selected slides
	 * 
	 * @param task
	 */
	public void performActionOnMany(Task task) {
		performActionOnMany(task, getActionOnMany());
	}

	/**
	 * Executes an action on all selected slides
	 * 
	 * @param list
	 * @param action
	 */
	public void performActionOnMany(Task task, StainingListAction action) {
		List<StainingTableChooser<?>> list = getStainingTableRows();

		List<Slide> slides = list.stream().filter(p -> p.isChoosen() && p.isStainingType())
				.map(p -> (Slide) p.getEntity()).collect(Collectors.toList());

		if (slides.isEmpty()) {
			logger.debug("Nothing selected, do not performe any action");
			return;
		}

		switch (getActionOnMany()) {
		case PERFORMED:
		case NOT_PERFORMED:
			logger.debug("Setting staining status of selected slides");
			slides.stream().forEachOrdered(p -> slideService.completedStaining(p,
					getActionOnMany() == StainingListAction.PERFORMED ? true : false));
			getGlobalEditViewHandler().getWorkPhase().updateStainingPhase(
					taskRepository.save(task, resourceBundle.get("log.task.slide.completed", task)));
			break;
		case ARCHIVE:
			// TODO implement
			System.out.println("To impliment");
			break;
		case PRINT:

			// SlideLable slideLabel = DocumentTemplate
			// .getTemplateByID(globalSettings.getDefaultDocuments().getSlideLabelDocument());
			//
			// if (slideLabel == null) {
			// logger.debug("No template found for printing, returning!");
			// return;
			// }
			//
			// logger.debug("Printing labes for selected slides");
			//
			// List<SlideLable> toPrint = new ArrayList<SlideLable>();
			//
			// for (StainingTableChooser<?> stainingTableChooser : list) {
			// if (stainingTableChooser.isChoosen() &&
			// stainingTableChooser.isStainingType()) {
			//
			// Slide slide = (Slide) stainingTableChooser.getEntity();
			//
			// SlideLable tmp = (SlideLable) slideLabel.clone();
			// tmp.initData(task, slide, new Date(System.currentTimeMillis()));
			// tmp.fillTemplate();
			// toPrint.add(tmp);
			// }
			// }
			//
			// if (toPrint.size() != 0) {
			// try {
			// userHandlerAction.getSelectedLabelPrinter().print(toPrint);
			// } catch (CustomUserNotificationExcepetion e) {
			// // handling offline error
			// mainHandlerAction.sendGrowlMessages(e);
			// }
			// }

			break;
		default:
			break;
		}

		setActionOnMany(StainingListAction.NONE);

	}

	@Override
	public void loadView() {
		setActionOnMany(StainingListAction.NONE);
		setStainingTableRows(StainingTableChooser.factory(getTask(), false));
	}

}